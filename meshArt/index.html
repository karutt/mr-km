<!doctype html>
<html lang='ja'>
<head prefix='og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# website: http://ogp.me/ns/website#'>
	<meta content="IE=edge" http-equiv="X-UA-Compatible">
	<meta charset="utf-8">
	<meta content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport">

	<meta property="og:locale" content="ja_JP"/>
	<meta property="og:locale:alternate" content="ja_JP"/>
	<meta property="og:site_name" content="km-mr.net"/>
	<meta property="og:description" content="Mitsuru Koyama Portfolio"/>
	<meta property="og:image" content="https://karutt.github.io/mrkm/assets/img/ogpImage.png"/>
	<meta property="og:image:secure_url" content="https://karutt.github.io/mrkm/assets/img/ogpImage.png"/>
	<meta property="og:image:type" content="image/png"/>
	<meta property="og:image:width" content="600"/>
	<meta property="og:image:height" content="600"/>
	<meta property="og:title" content="Mesh Art"/>
	<meta property="og:url" content="https://karutt.github.io/meshArt/"/>

	<title>Mesh Art</title>

	<link rel="apple-touch-icon" sizes="180x180" href="./assets/img/favicons/apple-touch-icon.png">
	<link rel="icon" type="image/png" href="./assets/img/favicons/favicon-32x32.png" sizes="32x32">
	<link rel="icon" type="image/png" href="./assets/img/favicons/favicon-16x16.png" sizes="16x16">
	<link rel="manifest" href="./assets/img/favicons/manifest.json">
	<link rel="mask-icon" href="./assets/img/favicons/safari-pinned-tab.svg" color="#5bbad5">
	<meta name="theme-color" content="#ffffff">

	<link href='//fonts.googleapis.com/css?family=Lato:300,400' rel='stylesheet' type='text/css'>
	<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro" rel="stylesheet">
	<link href="/assets/style/main.css" rel="stylesheet" />
	<script src="/assets/js/syntaxhightlighter.js"></script>
	<script type="text/javascript">
	SyntaxHighlighter.defaults['toolbar'] = false;
	// SyntaxHighlighter.defaults['gutter'] = false;
	SyntaxHighlighter.all();
	</script>

</head>

<body class="meshArt meshArt_index">

	
<WorkHeader class="WorkHeader">


	<div class="WorkHeader-head">
		<a href="../" class="WorkHeader-head-phrase"><img src="../assets/img/logo2.png" alt="" class="WorkHeader-logo" /></a>
	</div>



	<!-- <div class="WorkHeader-body">
		<ul class="WorkHeader-menu">
			<li><a href="../#category" class="WorkHeader-menu-item">Work</a></li>
			<li><a href="../#concept" class="WorkHeader-menu-item">Concept</a></li>
			<li><a href="../#profile" class="WorkHeader-menu-item active">Profile</a></li>
		</ul>
	</div> -->

	<div class="WorkHeader-body">
		<ul class="WorkHeader-menu">
			<li>
<a href=".info1" class="WorkHeader-menu-item">			<img src="/assets/img/background-material/infoImage.png" class="WorkHeader-menu-image" alt="Infoimage" />
</a>			</li>
			<li><a href=".info2" class="WorkHeader-menu-item" style="margin-top: 2px">	&lt;/&gt;</a></li>
			<!-- <li><a href="../#category" class="WorkHeader-menu-item">Work</a></li> -->

		</ul>
	</div>


</WorkHeader>


	<div class="movie-wrap">
		<div class="movie-size">
<iframe width="1280" height="720" src="https://www.youtube.com/embed/sstna8f-baE?rel=0&amp;controls=0&amp;showinfo=0" frameborder="0" ></iframe>		</div>
	</div>

<div class="information info1">
	<div class="information-wrapper">
		<div class="information-header">Mesh Art</div>
		<div class="information-body">
			SF映画・SFアニメなどにありそうなデータ群を近未来的に視覚化したアニメーションです。
			複雑そうな動きに見えますが仕組みを説明すると、
			球面を細くカットし、色をつけ、回転させているだけです。
			これは球面すなわち曲面を作り出すためのテクニックを理解すれば、簡単に実装できます。
			球を描画すること自体は、sphere()関数を使うことが最も速いですが、欲しいのは球体の一部分です。
			これらの部分的な曲面にアクセスするためには、球を数式で作るところから始めました。
			立方体や球、複雑な３次元の立体図形を生成するには、数式を利用するのが最も簡単です。
			また立体図形の全ての基礎となるものは、２次元グリットに並べられた点です。
			この点が出来上がれば、グリッド上にできた点xとyの値を使い、点zの位置を決めていきます。
			球面お方程式は空間座標，ベクトル，極座標といった様々な方法で表すことができますが、processing（というか機械の世界全般）で扱いやすい
			三角関数を使った極座標で球を実装します。<br><br>
			<span>
				x = sin(α)・sin(β)・r;<br>
				y = sin(α)・cos(β)・r;<br>
				z = cos(α)・r;
			</span>
			<br><br>

			出来上がった球面の媒介変数α、βを調整して、球面を細くカットしていきます。
			あとはそれらのオブジェクトをどうデザインするかの問題ですが、
			オブジェクトの半径rや色を乱数や段階的な透過度・色の変化をつけることにより、近未来風に仕上げました。


		</div>
	</div>
</div>

<div class="information info2">
	<pre class="brush:pde">
		int num = 300;
		ArrayList<Sphere> spheres;

			void setup() {
				size(1280, 720, P3D);

				spheres = new ArrayList<Sphere>();
					for (int i = 0; i < num; i++) {
						addSphere(i);
					}
				}

				void draw() {

					background(0);

					//control camera
					float r = 800;
					float a = frameCount*0.01;
					float b = frameCount*0.01/2;
					float x = sin(a)*cos(b)*r;
					float y = sin(a)*sin(b)*r;
					float z = cos(a)*r;
					camera(x, y, z, 0, 0, 0, 0, 1, 0);

					for (int i = spheres.size()-1; i >= 0; i--) {
						Sphere sp = spheres.get(i);
						sp.update();
						sp.display();
						if (sp.isDead()) {
							spheres.remove(i);
							addSphere(i);
						}
					}
				}

				void addSphere(int i) {
					float len1 = random(PI/(40*noise(i/10) + 10));
					float len2 = random(PI);
					float xmin = random(-PI, PI-len1);
					float ymin = random(-PI/10, PI/10-len2);
					float xmax = xmin + len1;
					float ymax = ymin + len2;
					spheres.add( new Sphere(xmin, xmax, ymin, ymax, map(noise(i/5), 0, 1, 100, 400), i));
				}

				class Sphere {
					float xMin, xMax;
					float yMin, yMax;
					int xCount, yCount;
					float radius;
					PVector[][] points;

					color startColor;
					color endColor;
					color col;

					float angle;
					float randomAngle;

					float velocity;

					float lifespan;
					float lifespeed;

					int id;



					Sphere(float _xMin, float _xMax, float _yMin, float _yMax, float _radius, int _id) {
						xMin = _xMin;
						xMax = _xMax;
						yMin = _yMin;
						yMax = _yMax;

						xCount = 5;
						yCount = 20;
						radius = _radius;

						id = _id;

						points = new PVector[yCount+1][xCount+1];

						startColor = color(204, 102, 0);
						endColor = color(46, 211, 2);
						col = lerpColor(startColor, endColor, map(id, 0, num, 0, 1));

						angle = 0;
						randomAngle = TWO_PI*noise(id/10);

						velocity = random(-0.03, 0.03);

						lifespan = 1;
						lifespeed = random(1, 3);

						init();
					}

					void init() {
						for (int iv = 0; iv <= yCount; iv++) {
							for (int iu = 0; iu <= xCount; iu++) {
								float x = map(iu, 0, xCount, xMin, xMax);
								float y = map(iv, 0, yCount, yMin, yMax);
								points[iv][iu] = new PVector();
								points[iv][iu].x = sin(x)*sin(y) * radius;
								points[iv][iu].y = sin(x)*cos(y) * radius;
								points[iv][iu].z = cos(x) * radius;
							}
						}
					}

					void update() {
						angle += velocity;
						if (lifespan > 255) {
							lifespan = 255;
							lifespeed *= -1;
						}
						lifespan += lifespeed;
						startColor = color(204, 102, 0);
						endColor = color(46, 211, 2);
						col = lerpColor(startColor, endColor, map(id, 0, num, 0, 1));
					}

					void display() {
						fill(col, lifespan);
						stroke(col, 50);

						pushMatrix();
						rotateX(randomAngle);
						rotateZ(angle);

						for (int iv = 0; iv < yCount; iv++) {
							beginShape(TRIANGLE_STRIP);
							for (int iu = 0; iu <= xCount; iu++) {
								vertex(points[iv][iu].x, points[iv][iu].y, points[iv][iu].z);
								vertex(points[iv+1][iu].x, points[iv+1][iu].y, points[iv+1][iu].z);
							}
							endShape();
						}
						popMatrix();
					}

					boolean isDead() {
						if (lifespan < 0) return true;
						else return false;
					}
				}

			</pre>
		</div>
		<!-- <div class="explanation">
		<div class="explanation-wrapper">

		<h1 class="explanation-h1">Mesh art 解説</h1>

		<ul class="explanation-list">
		<li><a href="#list1" class="explanation-list-item">概要</a></li>
		<li><a href="#list2" class="explanation-list-item">2次元グリッド</a></li>
		<li><a href="#list3" class="explanation-list-item">曲面を作る</a></li>
		<li><a href="#list4" class="explanation-list-item">第２の座標系</a></li>
		<li><a href="#list5" class="explanation-list-item">球を作る</a></li>
	</ul>

	<h2 class="explanation-h2" id="list1">概要</h2>
	<div class="explanation-body">
	SF映画・アニメなどにありそうな、データ群をスタイリッシュに視覚化したアニメーションです。
	複雑そうな動きに見えますが、仕組みを説明すると、
	球面を細くカットし、色をつけ、回転させているだけです。
	ですので、『球面』、もっと言えば『曲面』をどのように作り出すかを理解すれば、簡単に作ることができます。
	球を描画すること自体は、sphere()関数を使うことが最も早いですが、欲しいのは球体の一部分です。
	これらの部分的な曲面にアクセスするためには、球を数式で作るところから始めます。
	以下では、Processingでの実装方法を解説していきます。
</div>

<h2 class="explanation-h2" id="list2">2次元グリッド</h2>
<div class="explanation-body">

立方体や球、複雑な３次元の立体図形を生成するには、数式を利用するのが最も簡単です。
全ての基礎となるものは、２次元グリットに並べられた点です。
この点さえあれば、あとは数式に従い３次元空間上に割り当てていくだけです。

２次元グリッドは以下のように実装します。

<pre class="brush:pde">
void draw() {
float xCount = 20;
float yCount = 20;
scale(40);
strokeWeight(1/40.0);
for(int y = 0; y < yCount; y++) {
beginShape(TRIANGLE_STRIP);
for(int x = 0; x <= xCount; x++) {
vertex(x, y);
vertex(x, y+1);
}
endShape();
}
}
</pre>

<img src="/assets/img/assets/img/meshArt/code1.png" class="explanation-image" alt="Code1" />

beginshape(), vertex(), endShape(),の３つの関数を使い、格子状に並ぶ点から、順次タイルの平面を作ります。
<img src="/assets/img/assets/img/meshArt/grid2d.png" class="explanation-image" alt="Grid2d" />
３つの関数について詳しく知りたい場合は,Processing公式サイトの
<a href="https://processing.org/reference/beginShape_.html" target="_blank">リファレンス</a>を参照してください。図を使いわかりやすく説明がされています。
</div>
<h2 class="explanation-h2" id="list3">曲面を作る</h2>
<div class="explanation-body">
前章で実装したのはxとy軸にある２次元グリッドからなる平面でした。ここへ、グリッド上にできた点xとyの値を使いz軸の位置を決めていきます。
<pre class="brush:pde; highlight: [9, 10,12]">
void draw() {
float xCount = 20;
float yCount = 20;
scale(40);
strokeWeight(1/40.0);
for(int y = 0; y < yCount; y++) {
beginShape(TRIANGLE_STRIP);
for(int x = 0; x <= xCount; x++) {
float dist = sqrt(x*x + y*y);
float z = sin(dist);
vertex(x, y, z);
z = sin(sqrt(x*x+(y+1)*(y+1));
vertex(x, y+1, z);
}
endShape();
}
}
</pre>

結果を見てみましょう。
<img src="/assets/img/assets/img/meshArt/code2.png" class="explanation-image" alt="Code2" />
float dist = sqrt(x*x + y*y);<br>
この行は原点を中心に、離れれば離れるほど距離(dist)が大きくなることを示します。
それを三角関数sinの角度として割り当てます。そうすると、原点を中心としたサインカーブが生まれ、
水面へ石を投げ込んだ時のような波ができます。
</div>

<h2 class="explanation-h2" id="list4">第2の座標系</h2>
<div class="explanation-body">
複雑な数式を用いる場合、元々のグリッドのための座標系と３次元に変換された図形のための座標系
の２つを用意します。
コードを見てみましょう。

<pre class="brush:pde; highlight: [12,13, 15, 16, 17]">
int uCount = 30;
float uMin = 0;
float uMax = 5;

int vCount = 30;
float vMin = -1;
float vMax = 1;

for (float iv = 0; iv < vCount; iv++) {
beginShape(QUAD_STRIP);
for (float iu = 0; iu <= uCount; iu++) {
float u = map(iu, 0, uCount, uMin, uMax);
float v = map(iv, 0, vCount, vMin, vMax);

float x = u;
float y = v;
float z = cos(sqrt(u*u + v*v));
vertex(x, y, z);

v = map(iv+1, 0, vCount, vMin, vMax); //一つ下の格子点

x = u;
y = v;
z = cos(sqrt(u*u + v*v));
vertex(x, y, z);
}
endShape();
}
</pre>

<img src="/assets/img/assets/img/meshArt/code4.png" class="explanation-image" alt="Code4" />

u, vの媒介変数をuMin, uMaxとvMin, vMaxの規定された範囲の値で制御します。
<img src="/assets/img/assets/img/meshArt/code3.png" class="explanation-image" alt="Code3" />
これら変数で何ができるようになったのでしょうか。uMin, uMax, vMin, vMaxはu,vの範囲、
すなわち曲面の大きさを調整できます。uCount, vCountはグリッドのキメの細かさ、すなわち
曲面の滑らかさ・解像度を調整します。上の画像でu,vの範囲を変えずに　uCount = 100; vCount = 100;
と変更したとしましょう。その場合グリッドの数は10×10から100×100へ変化し細かくなります。<br>
数式の当てはめ方は先ほど一緒で、媒介変数u, vを介してx, y, zを定めているだけです。
</div>
<h2 class="explanation-h2" id="list5">球を作る</h2>
<div class="explanation-body">
さて、立体図形の作り方はわかりましたが、ピースが一つ足りません。球面の方程式です。
空間座標，ベクトル，極座標といった様々な方法で表すことができますが、processing（というか機械の世界全般）で扱いやすい
三角関数を使った極座標で球を実装しましょう。
<pre class="brush:pde">
x = sin(α)・sin(β)・r;
y = sin(α)・cos(β)・r;
z = cos(α)・r;
</pre>

数式がわかれば、これを先ほどのコードに書き加えるだけです。
</div>
</div> -->
</div>


	<!--
	<script src="../assets/js/jquery-2.1.4.min.js"></script>
	<script type="text/javascript" src="../assets/js/jquery.easing.1.3.js"></script>
	<script src="../assets/js/script.js"></script> -->
	<script src="/assets/js/jquery-2.1.4.min.js"></script>
	<script src="/assets/js/jquery.easing.1.3.js"></script>
	<script src="/assets/js/script.js"></script>




</body>
</html>
